# Введение в таблицы лута

Таблицы лута - это файлы в формате JSON, используемые для определения того, как предметы генерируются в игре. Они могут
использоваться для создания содержимого сундуков, определения предметов, которые выпадают после смерти, или даже
предметов, которыми экипирован моб. В некоторых случаях они даже используются в таких игровых механиках, как доение
коровы мухомор или рыбалка.

Таблицы лута обычно состоят из трех основных разделов, называемых "пул".

+ Броски
    + Сколько раз этот пул будет брошен для выбора предмета. Это может быть либо целое число, которое задает количество
      бросков, либо минимальный/максимальный диапазон, из которого может быть выбрано количество бросков.
+ Условия (необязательно)
    + Это условия, которые должны быть выполнены, чтобы этот пул был запущен.
+ Записи
    + Это список объектов, которые игра будет выбирать в этом броске. Это может быть предмет, loot_table или пустой
      список, если вы хотите, чтобы в этом броске ничего не произошло.

В этом руководстве вы узнаете следующее:

+ Как использовать JSON для определения таблицы лута.
+ Как применять функции к элементам для изменения выбранного предмета.
+ Как использовать условия для дальнейшего ограничения выбора пула или элемента.

### Требования

Перед тем как приступить к изучению данного руководства, рекомендуется выполнить следующие задания.

+ [Введение в наборы параметров](Introduction_to_Behavior_Packs.md)

## Основное использование

Сначала создадим таблицу лута, которая при вызове возвращает один алмаз.

``` json
{
    "pools": [
        {
            "rolls": 1,
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond"
                }
            ]
        }
    ]
}
```

Как вы можете видеть, мы определили один пул, который бросается только один раз и содержит один алмаз при каждом броске.
Если объединить это с
компонентом [minecraft:loot](../../Reference_Documentation/Behavior_Pack/Entity_JSON/Properties/loot.md) в файле
поведения сущности, то при смерти она будет бросать этот алмаз.

Теперь, что если вы хотите выбирать из двух предметов? Что если бы мы хотели вернуть алмаз или кусок угля? Этого можно
добиться, добавив второе значение к объекту `entries`.

``` json
{
    "pools": [
        {
            "rolls": 1,
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond"
                },
                {
                    "type": "item",
                    "name": "minecraft:coal"
                }
            ]
        }
    ]
}
```

Теперь вы заметите, что вероятность падения алмаза не меньше, чем вероятность падения кусочка угля. Всем `entries`
присваивается `weight`. Если вы не укажете его, то по умолчанию он будет равен `1`, что дает всем `entries` равные шансы
быть брошенными. Чтобы изменить это, нам нужно самим определить значение `weight`.

``` json
{
    "pools": [
        {
            "rolls": 1,
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond",
                    "weight": 1
                },
                {
                    "type": "item",
                    "name": "minecraft:coal",
                    "weight": 7
                }
            ]
        }
    ]
}
```

Лучший способ понять, как `weight` влияет на бросок - это представить, что в приведенном выше примере не две позиции, а
восемь: семь шансов для угля и один шанс для алмаза. Это означает, что вероятность того, что в результате броска выпадет
кусок угля, а не алмаз, в семь раз выше.

Несмотря на то, что модификатор `quality` из Java Edition (который корректирует `weight` в зависимости от атрибута удачи
игрока) существует в ванильных файлах Bedrock Edition, Bedrock Edition в настоящее время не поддерживает атрибут удачи,
что лишает эту функцию всякой пользы.

Вы также можете рандомизировать количество бросков набора `entries`. Ключ `rolls` можно задать с `min` и `max`
значением, которое игра будет выбирать случайным образом.

``` json
{
    "pools": [
        {
            "rolls": {
                "min": 1,
                "max": 3
            },
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond",
                    "weight": 1
                },
                {
                    "type": "item",
                    "name": "minecraft:coal",
                    "weight": 7
                }
            ]
        }
    ]
}
```

Вышеуказанные действия заставят игру бросить предметы от одного до трех раз. В результате каждый раз при вызове таблицы
лута будет выпадать минимум один предмет и максимум три.

Вот еще один пример с использованием таблицы лута в качестве одной из записей. Это заставит игру вызвать другую таблицу
лута и вернуть все, что получится в результате.

``` json
{
    "pools": [
        {
            "rolls": {
                "min": 1,
                "max": 3
            },
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond",
                    "weight": 1
                },
                {
                    "type": "item",
                    "name": "minecraft:coal",
                    "weight": 7
                },
                {
                    "type": "loot_table",
                    "name": "loot_tables/custom/some_loot_table",
                    "weight": 1
                }
            ]
        }
    ]
}
```

Имейте в виду, что таблицы лута не могут ссылаться на себя каким-либо образом. Если в результате броска получится
рекурсивная таблица награбленного, ничего не будет возвращено.

## Функции и модификация элементов

Функции - это дополнительные операции, которые могут быть добавлены к записи, изменяющей элемент. Они могут позволить
вам определить, сколько элементов будет возвращено, изменить атрибуты элемента или выполнить любое другое действие. В
этой статье мы рассмотрим некоторые наиболее распространенные варианты использования функций, но вы можете получить
подробное объяснение всех доступных функций в
учебнике [Функции таблиц лута и торговли](Loot_and_Trade_Table_Functions.md).

### set_count

Это позволяет установить минимальное и максимальное количество предметов, возвращаемых с данной записью:

``` json
{
    "type": "item",
    "name": "minecraft:diamond",
    "weight": 1,
    "functions": [
        {
          "function": "set_count",
          "count": {
            "min": 1,
            "max": 6
          }
        }
    ]
}
```

Приведенный выше пример будет возвращать от одной до шести алмазов всякий раз, когда выпадает эта запись.

### set_data

Устанавливает значение данных предмета. Это полезно для таких вещей, как возврат определенного зелья или определенного
цвета красителя. Он также позволяет возвращать различные значения блоков, например, определенный цвет шерсти или
определенный тип бревна.

``` json
{
    "type": "item",
    "name": "minecraft:potion",
    "weight": 1,
    "functions": [
      {
        "function": "set_data",
        "data": 21
      }
    ]
}
```

В приведенном выше примере будет возвращено зелье исцеления.

``` json
{
    "type": "item",
    "name": "minecraft:wool",
    "weight": 1,
    "functions": [
      {
        "function": "set_data",
        "data": 1
      }
    ]
}
```

В этом примере будет возвращена оранжевая шерсть.

### specific_enchants

Эта функция позволяет установить список определенных зачарований на предмет. Это позволяет накладывать чары на предметы,
которые обычно не могут быть зачарованы в игре.

``` json
{
    "type": "item",
    "name": "minecraft:stick",
    "weight": 1,
    "functions": [
        {
          "function": "specific_enchants",
          "enchants": [
             "knockback",
             "fire_aspect"
          ]
        }
    ]
}
```

Вы можете определить зачарования как объекты, чтобы также определить уровень зачарования. Максимальные уровни
зачарований жестко закодированы и не могут быть перезаписаны.

``` json
{
    "type": "item",
    "name": "minecraft:stick",
    "weight": 1,
    "functions": [
        {
          "function": "specific_enchants",
          "enchants": [
             {
                "id": "knockback",
                "level": 1
             },
             {
                "id": "unbreaking",
                "level": 3
             }
          ]
        }
    ]
}
```

### Множественные функции

Можно определить несколько функций. Вот пример объединения двух функций. В данном примере эта запись вернет от одного до
трех зелий исцеления.

``` json
{
    "type": "item",
    "name": "minecraft:potion",
    "weight": 1,
    "functions": [
        {
            "function": "set_count",
            "count": {
              "min": 1,
              "max": 3
            }
        },
        {
            "function": "set_data",
            "data": 21
        }
    ]
}
```

Несколько функций могут быть даже несколькими функциями одной и той же функции, но если между этими функциями возникает
конфликт, победит та, которая была определена последней.

Например, использование нескольких функций `set_count`, как в приведенном ниже примере, приведет к тому, что будет
использоваться только последняя из дубликатов, в результате чего элемент будет иметь счетчик от 5 до 7, а не от 1 до 3.

``` json
{
    "type": "item",
    "name": "minecraft:potion",
    "weight": 1,
    "functions": [
        {
            "function": "set_count",
            "count": {
              "min": 1,
              "max": 3
            }
        },
        {
            "function": "set_count",
            "count": {
              "min": 5,
              "max": 7
            }
        }
    ]
}
```

## Условия

Условия - это список требований, которые должны быть выполнены, прежде чем можно будет использовать пул или выбрать
отдельную запись. Все условия хранятся в списке условий. Каждое условие выполняется по очереди. Если одно из условий в
списке не выполняется, остальные в том же списке игнорируются.

### Условия для пула

Применение условия к пулу позволяет выполнить весь пул на основе заданных условий.

Приведенный ниже пример сработает только в том случае, если вызывающий его объект был убит скелетом, в результате чего
получил либо алмаз, либо кусок угля.

``` json
{
    "pools": [
        {
            "conditions": [
                {
                    "condition": "killed_by_entity",
                    "entity_type": "minecraft:skeleton"
                }
            ],
            "rolls": 1,
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond",
                    "weight": 1
                },
                {
                    "type": "item",
                    "name": "minecraft:coal",
                    "weight": 1
                }
            ]
        }
    ]
}
```

### Условия ввода

Вы также можете применить условия к определенным `entries` внутри броска. Следующий пример будет возвращать алмаз только
в 50% случаев, если вызвавший его объект был убит игроком. Во всех остальных случаях он будет возвращать уголь.

``` json
{
    "pools": [
        {
            "rolls": 1,
            "entries": [
                {
                    "type": "item",
                    "name": "minecraft:diamond",
                    "weight": 1,
                    "conditions": [
                        {
                            "condition": "killed_by_player"
                        }
                    ]
                },
                {
                    "type": "item",
                    "name": "minecraft:coal",
                    "weight": 1
                }
            ]
        }
    ]
}
```

Изучение различных доступных функций и условий может позволить вам по-настоящему настроить опыт игрока. Вы можете давать
предметам имена и наделять их историей, бросать ящики с ресурсами, полные припасов, и даже создавать письменные книги
для инструкций или информации.

### Что дальше?

Существует множество других функций, которые могут изменять выбранный элемент. В следующем уроке мы рассмотрим их.

[Функции таблиц лута и торговли](Loot_and_Trade_Table_Functions.md)